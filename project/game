import sys
import pygame
import math
from pygame.locals import QUIT
from math import sin, cos

pygame.init()

'''
class Pointer():
    def __init__(self, WINDOW_WIDTH, WINDOW_HEIGHT, fi) -> None:
        self.image = pygame.image.load(fi)
        self.size = self.image.get_size()
        self.pos = (WINDOW_WIDTH/2-self.size[0]/2, WINDOW_HEIGHT-self.size[1])
    
    def blit(self):
        #self.image.fill(TRANSPARENT)
        window_surface.blit(self.image, self.pos)
        pygame.display.update()
        return

    def rot_center(self, angle):
        """rotate an image while keeping its center and size"""
        orig_rect = self.image.get_rect()
        rot_image = pygame.transform.rotozoom(self.image, angle, 1)
        rot_rect = orig_rect.copy()
        rot_rect.center = rot_image.get_rect().center
        rot_image = rot_image.subsurface(rot_rect).copy()
        return rot_image
'''

class Barriers():
    def __init__(self, x, y, width, height):
        self.x = x
        self.y = y
        self.width = 500 / 10  # Set maximum width of block = 1/10 of the window width
        self.height = self.width

    def render(self, window_surface):
        pygame.draw.rect(window_surface, (100,0,0), (self.x, self.y, self.width, self.height), 0) # Set Block as Red as color (temp)


class Balls(pygame.sprite.Sprite):
    def __init__(self, width, height,pos_x, pos_y) -> None:
        super().__init__()
        self.image = pygame.Surface([width,height])
        self.image.fill((0,0,0))
        self.rect = self.image.get_rect()
        self.rect.center = (pos_x, pos_y)
        self.is_move = False
        self.x_speed = 0
        self.y_speed = 0
        self.radius = radius
        self.pause = 0

    def is_move(self):
        self.is_move = True
        
    def update(self):
        if self.is_move == True:
            if self.pause == 0:
                pos_x = self.rect.center[0]
                pos_y = self.rect.center[1]
                pos_x += 10 * self.x_speed
                pos_y -= 10 * self.y_speed
                self.rect.center = (pos_x, pos_y)
                print(self, self.rect.center)
                if (ball.rect.center[0] <= self.radius and self.x_speed <= 0)or (ball.rect.center[0] >= WINDOW_WIDTH-self.radius and self.x_speed >= 0):
                    self.x_speed *= -1
                if ball.rect.center[1] <= self.radius and self.y_speed >= 0 :
                    self.y_speed *= -1
                if self.rect.center[1] >= WINDOW_HEIGHT+25:
                    ball.rect.center = (WINDOW_WIDTH/2, WINDOW_HEIGHT-26)
                    self.is_move = False
            else:
                self.pause -= 1

# 
#     def check_hit_bound(self):
#         if (ball.rect.center[0] <= self.radius and self.x_speed <= 0)or (ball.rect.center[0] >= WINDOW_WIDTH-self.radius and self.x_speed >= 0):
#                 self.x_speed *= -1
#         if ball.rect.center[1] <= self.radius and self.y_speed >= 0 :
#                 self.y_speed *= -1
# 



def generate_blocks(window_surface):
    # Test Level
    level_test = [
        [0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0],
        [0,0,1,1,1,0,0,0,0,0],
        [0,0,0,1,1,0,0,0,0,0],
        [0,0,0,1,1,0,0,0,0,0],
        [0,0,0,1,1,0,0,0,0,0],
        [0,0,0,1,1,1,1,0,0,0],
        [0,0,0,0,0,0,0,0,0,0]
    ]

    block_generate = []

    for i in range(len(level_test)):
        for j in range(len(level_test[i])):
            if (level_test[i][j] == 1):
                block_generate.append(Barriers(j * 50, i * 50, 50, 50))
    
    for blocks in block_generate:
        Barriers.render(blocks, window_surface)



WINDOW_WIDTH = 500
WINDOW_HEIGHT = 600
WHITE = (255, 255, 255)
FPS = 30
fi_pointer = "files/pointer.jpg"
degree = 90
radius = 25
clock = pygame.time.Clock()

window_surface = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
pygame.display.set_caption("GAME")
window_surface.fill(WHITE)


# pointer = Pointer(WINDOW_WIDTH, WINDOW_HEIGHT, fi_pointer)
# pointer.blit()


ball = Balls(50,50, WINDOW_WIDTH/2, WINDOW_HEIGHT-26)
# ball_2 = Balls(50,50, WINDOW_WIDTH/2, WINDOW_HEIGHT-26)
ball_group = pygame.sprite.Group()
ball_group.add(ball)
# ball_group.add(ball_2)

# ball_2.pause = FPS
# for i in ball_group:
#     print(i)


is_degree_change = False
change_value = 0


while True:
    clock.tick(FPS)
    rad = degree/180 * math.pi

    window_surface.fill(WHITE)

    # Generate Blocks (TEST)
    generate_blocks(window_surface)

    #move the pointer
    if is_degree_change == True:
        degree += change_value
        if degree > 170:
            degree = 170
        if degree < 10:
            degree = 10

    for event in pygame.event.get():
        if event.type == pygame.KEYDOWN:
            ''''
            if event.key == ord("a"):
                pointer.image = pointer.rot_center(1)
                pointer.blit()
            if event.key == ord("d"):
                pointer.image = pointer.rot_center(-1)
                pointer.blit()
            '''
            #change the angle 
            if event.key == ord("a"):
                if ball.is_move == False:
                    is_degree_change = True
                    change_value = 1
            if event.key == ord("d"):
                if ball.is_move == False:
                    is_degree_change = True
                    change_value = -1

            #shoot
            if event.key == ord("w"):
                for balls in ball_group:
                    balls.x_speed = cos(rad)
                    balls.y_speed = sin(rad)
                    balls.is_move = True

        #keyup to stop the pointer 
        if event.type == pygame.KEYUP:
            is_degree_change = False
            change_value = 0

        if event.type == QUIT:
            pygame.quit()
            sys.exit()

    # for balls in ball_group:
    #     balls.check_hit_bound()
    
    ball_group.draw(window_surface)
    
    for balls in ball_group:
        balls.update()

    pygame.draw.line(window_surface, (255, 0, 0), (WINDOW_WIDTH/2, WINDOW_HEIGHT-25), (WINDOW_WIDTH/2 + 100*cos(rad), (WINDOW_HEIGHT-25)-100*sin(rad)), 3)
    pygame.display.update()