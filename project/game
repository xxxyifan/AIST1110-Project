import sys
import pygame
import math
import random
from pygame.locals import QUIT
from math import sin, cos
from copy import copy, deepcopy
import time

pygame.init()


'''
class Pointer():
    def __init__(self, WINDOW_WIDTH, WINDOW_HEIGHT, fi) -> None:
        self.image = pygame.image.load(fi)
        self.size = self.image.get_size()
        self.pos = (WINDOW_WIDTH/2-self.size[0]/2, WINDOW_HEIGHT-self.size[1])
    
    def blit(self):
        #self.image.fill(TRANSPARENT)
        window_surface.blit(self.image, self.pos)
        pygame.display.update()
        return

    def rot_center(self, angle):
        """rotate an image while keeping its center and size"""
        orig_rect = self.image.get_rect()
        rot_image = pygame.transform.rotozoom(self.image, angle, 1)
        rot_rect = orig_rect.copy()
        rot_rect.center = rot_image.get_rect().center
        rot_image = rot_image.subsurface(rot_rect).copy()
        return rot_image
'''

# class Barriers():
#     def __init__(self, x, y, width, height):
#         self.x = x
#         self.y = y
#         self.width = 500 / 10  # Set maximum width of block = 1/10 of the window width
#         self.height = self.width

#     def render(self, window_surface):
#         pygame.draw.rect(window_surface, (100,0,0), (self.x, self.y, self.width, self.height), 0) # Set Block as Red as color (temp)


class Balls(pygame.sprite.Sprite):
    def __init__(self, radius, pos_x, pos_y, round, group, ball_group, block_group, upgrade_group) -> None:
        super().__init__(group, ball_group)
        # self.image = pygame.Surface([radius*2,radius*2])
        # self.image.fill((0,0,0))
        self.image = pygame.image.load("files/image/sphere1.png").convert_alpha()
        self.image = pygame.transform.scale(self.image, (radius * 2, radius * 2))
        self.rect = self.image.get_rect()
        self.rect.center = (pos_x, pos_y)
        self.is_move = False
        self.x_speed = 0
        self.y_speed = 0
        self.speed = 9
        self.radius = radius
        self.block = block_group
        self.ball = ball_group
        self.upgrade = upgrade_group
        self.group = group
        self.round = round
        self.org_board = deepcopy(blk_weight)

    def collison(self):
        #collison with other rect

        overlap_sprites = pygame.sprite.spritecollide(self, self.block, False)
        if overlap_sprites:
            for sprite in overlap_sprites:
                if blk_weight[sprite.x//50][sprite.y//50] == self.org_board[sprite.x//50][sprite.y//50]:
                    blk_weight[sprite.x//50][sprite.y//50] -= 1
                    if blk_weight[sprite.x//50][sprite.y//50] < 1:
                        sprite.kill()
        else:
            self.org_board = deepcopy(blk_weight)

            
            print("after collison")  
            for i in blk_weight:
                print(i)


        for i in pygame.sprite.spritecollide(self, self.ball, False):
            overlap_sprites.append(i)

        collision_tolerace = self.speed
        if overlap_sprites:
            for sprite in overlap_sprites:
                if abs(sprite.rect.top - self.rect.bottom) < collision_tolerace and self.y_speed < 0:
                    self.y_speed *= -1
                if abs(sprite.rect.bottom - self.rect.top) < collision_tolerace and self.y_speed > 0:
                    self.y_speed *= -1
                if abs(sprite.rect.left - self.rect.right) < collision_tolerace and self.x_speed > 0:
                    self.x_speed *= -1
                if abs(sprite.rect.right - self.rect.left) < collision_tolerace and self.x_speed < 0:
                    self.x_speed *= -1

        #collison with upgrade
        opverlap_upgrade = pygame.sprite.spritecollide(self, self.upgrade, True)
        if opverlap_upgrade:
            for upgrades in opverlap_upgrade:
                print(upgrades.upgrade_type)
                if upgrades.upgrade_type == "ball_split":
                    tmp_ball = Tmp_Balls(self.radius, self.rect.midright[0]-self.radius-1, self.rect.midright[1], self.round, self.group, self.ball, self.block, self.upgrade)
                    direction = random.choice(["x"])
                    if direction == "x":
                        tmp_ball.x_speed = self.x_speed * -1
                        tmp_ball.y_speed = self.y_speed
                    else:
                        tmp_ball.x_speed = self.x_speed
                        tmp_ball.y_speed = self.y_speed * -1
                    tmp_ball.speed = random.randint(11,15)
                    tmp_ball.is_move = True

    def kill_all_block(self):
        for sprite in self.block:
            sprite.kill()

    def update(self):
        if self.is_move == True:
            pos_x = self.rect.center[0]
            pos_y = self.rect.center[1]
            pos_x += self.speed * self.x_speed
            pos_y -= self.speed * self.y_speed
            self.rect.center = (round(pos_x), round(pos_y))

            #change moving dir with hit the border
            if (self.rect.center[0] <= self.radius and self.x_speed <= 0)or (self.rect.center[0] >= WINDOW_WIDTH-self.radius and self.x_speed >= 0):
                self.x_speed *= -1
            if self.rect.center[1] <= self.radius and self.y_speed >= 0 :
                self.y_speed *= -1
            
            #check collison
            self.collison()

            #end the move when move to the bootom of the screen
            if self.rect.center[1] >= WINDOW_HEIGHT+30:
                self.is_move = False
                self.rect.center = (WINDOW_WIDTH/2, WINDOW_HEIGHT-26)
                self.kill_all_block()
                round_update(blk_weight)
                create_blocks(blk_weight, self.round)
                generate_blocks(window_surface, blk_weight)
                self.org_board = deepcopy(blk_weight)
                self.round += 1

class Upgrade(pygame.sprite.Sprite):
    def __init__(self, pos, upgrade_type, upgrade_group, group) -> None:
        super().__init__(upgrade_group, group)
        self.upgrade_type = upgrade_type
        self.image = pygame.Surface((50,50))
        self.rect = self.image.get_rect(midtop = pos)

class Tmp_Balls(Balls, pygame.sprite.Sprite):
    def __init__(self, radius, pos_x, pos_y, round, group, ball_group, block_group, upgrade_group):
        Balls.__init__(self, radius, pos_x, pos_y, round ,group, ball_group, block_group, upgrade_group)
        pygame.sprite.Sprite.__init__(group, ball_group)
        self.image.fill((80, 80, 80))
    def update(self):
        if self.is_move == True:
            pos_x = self.rect.center[0]
            pos_y = self.rect.center[1]
            pos_x += self.speed * self.x_speed
            pos_y -= self.speed * self.y_speed
            self.rect.center = (round(pos_x), round(pos_y))

            #check collison
            self.collison()

            #change moving dir with hit the border
            if (self.rect.center[0] <= self.radius and self.x_speed <= 0)or (self.rect.center[0] >= WINDOW_WIDTH-self.radius and self.x_speed >= 0):
                self.x_speed *= -1
            if self.rect.center[1] <= self.radius and self.y_speed >= 0 :
                self.y_speed *= -1
            #end the move when move to the bootom of the screen
            if self.rect.center[1] >= WINDOW_HEIGHT+100:
                self.kill()
        


#TESTING USE
# class Block(pygame.sprite.Sprite):
#     def __init__(self, pos, group):
#         super().__init__(group)
#         self.image = pygame.Surface((50,50))
#         self.image.fill((0,255,0))
#         self.rect = self.image.get_rect(topleft = pos)

class Barriers(pygame.sprite.Sprite):
    def __init__(self, x, y, width, height, score, block_group, group):
        super().__init__(group, block_group)
        self.x = x
        self.y = y
        self.width = 500 / 10  # Set maximum width of block = 1/10 of the window width
        self.height = self.width
        self.score = score
        # self.image = pygame.Surface((self.width,self.height))
        # self.image.fill((Barriers.color_pick(self)))
        self.color_pick()
        self.rect = self.image.get_rect(topleft = (self.x, self.y))
        self.block_group = block_group

    # def render(self, window_surface):
    #     color = Barriers.color_pick(self)
    #     pygame.draw.rect(window_surface, color, (self.x, self.y, self.width, self.height), 0)
        
    # Choose Different Texture at different score
    def color_pick(self):
        # color = (255, 255, 255)
        if (self.score < 10): # 1-10: Red
            # color = (255, 0, 0)
            self.image = pygame.image.load("files/image/red.png").convert_alpha()
            self.image = pygame.transform.scale(self.image, (self.width, self.height))
        elif (self.score < 20): # 11-20: Orange
            # color = (255, 128, 0)
            self.image = pygame.image.load("files/image/red2.png").convert_alpha()
            self.image = pygame.transform.scale(self.image, (self.width, self.height))
        elif (self.score < 30): # 21-30: Yellow
            # color = (255, 255, 0)
            self.image = pygame.image.load("files/image/orange.png").convert_alpha()
            self.image = pygame.transform.scale(self.image, (self.width, self.height))
        elif (self.score < 40): # 31-40: Green
            # color = (0, 255, 0)
            self.image = pygame.image.load("files/image/green.png").convert_alpha()
            self.image = pygame.transform.scale(self.image, (self.width, self.height))
        elif (self.score < 50): # 41-50: Cyan
            # color = (0, 255, 255)
            self.image = pygame.image.load("files/image/lightblue.png").convert_alpha()
            self.image = pygame.transform.scale(self.image, (self.width, self.height))
        elif (self.score < 60): #51-60: Blue
            # color = (0, 0, 255)
            self.image = pygame.image.load("files/image/blue.png").convert_alpha()
            self.image = pygame.transform.scale(self.image, (self.width, self.height))
        elif (self.score < 70): #61-70: Purple
            # color = (255, 0, 255)
            self.image = pygame.image.load("files/image/purple.png").convert_alpha()
            self.image = pygame.transform.scale(self.image, (self.width, self.height))
        else:
            # color = (0, 0, 0) # Otherwise: Black
            self.image = pygame.image.load("files/image/gray.png").convert_alpha()
            self.image = pygame.transform.scale(self.image, (self.width, self.height))
        return

    # def score_changer(self, change):
        # self.score += change

    # def score_setter(self, set_score):
        # self.score = set_score

# Generate Blocks on screen
def generate_blocks(window_surface, blk_weight):

    for i in range(len(blk_weight)):
        for j in range(len(blk_weight[i])):
            if (blk_weight[i][j] >= 1):
                Barriers(i * 50, j * 50, 50, 50, blk_weight[i][j], block_group, all_sprites_gruop)
    
    # for blocks in block_generate:
    #     Barriers.render(blocks, window_surface)



# Move blocks downward after each round ends
def round_update(blk_weight):
    for i in range(len(blk_weight)):
        for j in range(len(blk_weight[i])-1, -1, -1):
            if j == 0:
                blk_weight[i][j] = 0
            else:
                blk_weight[i][j] = blk_weight[i][j - 1]
                if blk_weight[i][j] < 0:
                    blk_weight[i][j] = 0

# Random new blocks
def create_blocks(blk_weight, round):
    max_blk = 0
    # Avoid too many blocks in the beginning
    if round < 10:
        max_blk = 1
    elif round < 20:
        max_blk = 2
    elif round < 30:
        max_blk = 3
    elif round < 40:
        max_blk = 4
    elif round < 50:
        max_blk = 5
    elif round < 60:
        max_blk = 6
    elif round < 70:
        max_blk = 7
    elif round < 80:
        max_blk = 8
    else:
        max_blk = 9
    num_blk = random.randint(1, max_blk)

    # Avoid too high weighting on blocks at beginning
    max_weight = (round // 10) + 1

    copy_last = random.randint(0, 1) # 0: Not Copy Last Row, 1: Copy Pattern of Last Row

    if (copy_last == 1 and round > 20):
        for i in range(len(blk_weight)):
            if (blk_weight[i][1] > 1):
                blk_weight[i][0] = random.randint(1, max_weight)
    else:
        start_loc = random.randint(0, 9)
        if (start_loc + max_blk > 9):
            end_loc = 9
        else:
            end_loc = start_loc + max_blk
        for i in range(start_loc, end_loc + 1):
            blk_weight[i][0] = random.randint(1, max_weight)
    print("before collison")   
    for i in blk_weight:
        print(i)
    return blk_weight

WINDOW_WIDTH = 500
WINDOW_HEIGHT = 600
WHITE = (255, 255, 255)
FPS = 30
fi_pointer = "files/pointer.jpg"
degree = 90
radius = 25
clock = pygame.time.Clock()
round_ = 0

# Define an array which store the block location and block weighting
blk_weight = [
    [0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0],
    [0,0,0,0,0,0,0,0,0,0]
]

window_surface = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
pygame.display.set_caption("GAME")
window_surface.fill(WHITE)



    # Test ONLY 
    # round_update(blk_weight)
    # create_blocks(blk_weight, round)
    # generate_blocks(window_surface, blk_weight)
    # time.sleep(1)
    # round += 1

# pointer = Pointer(WINDOW_WIDTH, WINDOW_HEIGHT, fi_pointer)
# pointer.blit()
all_sprites_gruop = pygame.sprite.Group()
ball_group = pygame.sprite.GroupSingle()
block_group = pygame.sprite.Group()
barriers_group = pygame.sprite.Group()
upgrade_group = pygame.sprite.Group()
tmp_ball_group = pygame.sprite.Group()

#ball
ball = Balls(radius, WINDOW_WIDTH/2, WINDOW_HEIGHT-26, round_, all_sprites_gruop, ball_group, block_group, upgrade_group)


#block
# block_1 = Block((50, 260), [all_sprites_gruop, block_group])
# block_2 = Block((50, 100), [all_sprites_gruop, block_group])
# block_3 = Block((100, 260), [all_sprites_gruop, block_group])
# block_4 = Block((400, 400), [all_sprites_gruop, block_group])

#upgrade
# upgrade_type = random.choice(["add_damage", "ball_split"])
# upgrade_1 = Upgrade((200,150), "ball_split", upgrade_group, all_sprites_gruop)
# upgrade_2 = Upgrade((400,50), "ball_split", upgrade_group, all_sprites_gruop)
# upgrade_3 = Upgrade((100,500), "ball_split", upgrade_group, all_sprites_gruop)

# variable for change degree
is_degree_change = False
change_value = 0

#main game loop
while True:
    clock.tick(FPS)
    rad = degree/180 * math.pi

    #move the pointer
    if is_degree_change == True:
        degree += change_value
        if degree > 170:
            degree = 170
        if degree < 10:
            degree = 10

    for event in pygame.event.get():
        if event.type == pygame.KEYDOWN:
            ''''
            if event.key == ord("a"):
                pointer.image = pointer.rot_center(1)
                pointer.blit()
            if event.key == ord("d"):
                pointer.image = pointer.rot_center(-1)
                pointer.blit()
            '''

            # Generate Blocks (TEST)
            if event.key == pygame.K_SPACE:
                round_update(blk_weight)
                create_blocks(blk_weight, round_)
                generate_blocks(window_surface, blk_weight)
                round_ += 1

            #change the angle 
            if event.key == ord("a"):
                if ball.is_move == False:
                    is_degree_change = True
                    change_value = 1
            if event.key == ord("d"):
                if ball.is_move == False:
                    is_degree_change = True
                    change_value = -1

            #shoot
            if event.key == ord("w"):
                if ball.is_move == False:
                    ball.x_speed = cos(rad)
                    ball.y_speed = sin(rad)
                    ball.is_move = True

        #keyup to stop the pointer 
        if event.type == pygame.KEYUP:
            is_degree_change = False
            change_value = 0

        if event.type == QUIT:
            pygame.quit()
            sys.exit()

    # window_surface.fill(WHITE)
    bg = pygame.image.load("files/image/Full-Background.png").convert()
    bg = pygame.transform.scale(bg, (WINDOW_WIDTH, WINDOW_HEIGHT))
    window_surface.blit(bg, (0, 0))
    all_sprites_gruop.update()
    all_sprites_gruop.draw(window_surface)
    pygame.draw.line(window_surface, (255, 0, 0), (WINDOW_WIDTH/2, WINDOW_HEIGHT-25), (WINDOW_WIDTH/2 + 100*cos(rad), (WINDOW_HEIGHT-25)-100*sin(rad)), 3)
    pygame.display.update()